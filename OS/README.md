# 1. 프로세스 VS 쓰레드

## 프로세스

- 코드(프로그램)가 메모리에 적재되어 실행된 상태 or 자원을 할당받는 작업단위.
- 메모리에 올라갈 때 운영체제로부터 시스템 자원을 할당받게 된다. 프로세스마다 독립된 메모리 영역 code/data/stack/heap 영역을 할당 받는다.
  - stack -> 함수의 매개변수, 복귀 주소 지역 변수와 같은 함수 호출 정보를 가짐.
  - data -> 전역 변수들을 가짐.
  - heap -> 동적으로 할당되는 메모리.

## stack

- 함수호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.
- 스텍 영역은 함수호출과 함께 할당되며, 호출이 완료되면 소멸된다.
- 스택 영역에 저장되는 호출 정보를 '스택 프레임'이라고 한다.
  - 스택 프레임 : 높은 주소에서 낮은 주소로 쌓이고 각 함수당 지역변수, 매개변수, 반환주소값을 가지고 있다.

|                  프로그램                  | VS  |                  프로세스                  |
| :----------------------------------------: | :-: | :----------------------------------------: |
| 코드와 같은 정적 데이터를 가진 정적인 객체 |     | 현재 관리하는 자원 정보를 가진 동적인 객체 |

### 프로세스 제어 블록(Process Control Block, PCB)

- 프로세스의 상태정보를 저장하고 있는 구조체이다.
- 프로세스 생성시 만들어지며 주기억장치에 유지된다.
- 프로세스 상태관리와 문맥교환을 위해 필요하다.

  - 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다. 프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 한다. 이때, 작업의 진행 상황을 모두 PCB에 저장하게 된다. 그리고 다시 CPU를 할당받게 되면 PCB에 저장되어있던 내용을 불러와 이전에 종료되었던 시점부터 다시 작업을 수행한다.

    | PCB                    | 설명                          |
    | :--------------------- | :---------------------------- |
    | PID                    | 프로세스의 고유 번호          |
    | Process state          | 준비,대기,실행 등의 상태      |
    | Priority               | 스케줄링 및 프로세스 우선순위 |
    | 포인터                 | 다음 실행될 프로세스의 포인터 |
    | Register information   | 레지스터 관련 정보            |
    | Memory information     | 할당된 자원 정보              |
    | Accounting information | CPU 사용시간, 실제 사용시간   |
    | I/O information        | 입출력 상태 정보              |

---

## 쓰레드

- 프로세스 내에 실행되는 실행 흐름의 단위
- 프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지는 같은 프로세스 내 다른 쓰레드와 공유한다.

### 쓰레드마다 스택을 독립적으로 할당하는 이유

- 스택은 함수호출 정보를 저장하기 위해 사용되는 메모리 공간이다.
- 스택 메모리 공간이 독립적이라는 것은 독립적인 함수호출이 가능하다는 것이고, 이는 독립적인 실행 흐름이 추가된다는 것이다.

---

# 2. 멀티 프로세스와 멀티 쓰레드

- 멀티 프로세스

  - 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것.
  - 장점
    - 각 프로세스는 서로 영향이 없어 하나에 문제가 발생하더라도 나머지는 정상 작동한다.
  - 단점
    - 많은 메모리 공간과 CPU시간을 차지한다.
    - 각각의 고유한 메모리 공간을 가지므로 자원 공유시 오버헤드가 크다.
    - 문맥교환에 비용이 많이 든다.

- 멀티 쓰레드
  - 하나의 프로세스를 여러 스레드로 병렬처리 하는 것.
  - 장점
    - 모든 스레드가 서로 자원과 메모리를 공유하므로 적은 메모리 공간과 문맥교환이 빠르다.
  - 단점
    - 교착상태가 발생할 수 있다. 여러 쓰레드가 하나의 자원에 동시에 접근.
    - 서로 영향을 미치므로 하나에 이상이 생기면 전체 쓰레드에 영향을 미친다.

---

# 3. 사용자 수준 쓰레드, 커널 수준 쓰레드, 혼합 쓰레드

- 메모리 영역은 사용자에 의해 할당되는 '유저 영역', 운영체제라는 소프트웨어를 실행시키기 위한 '커널 영역'으로 나뉜다.
- 사용자레벨 쓰레드와 커널레벨 쓰레드는 생성 주체가 누구인지에 따라 구분된다.

## 사용자 수준 쓰레드

- 쓰레드와 관련된 모든 행위를 사용자 영역에서 한다.
- 쓰레드 라이브러리를 이용하여 작동하는 형태.
- 단일 프로세서에서 작동한다. N:1 매핑
- 커널이 쓰레드의 존재를 알지 못 한다.
- 장점
  - 이식성이 높다.
    - 운영체제에서 스레드를 지원할 필요가 없다.
    - 커널 모드/유저 모드 간 전환이 일어나지 않기에 오버헤드가 적다.
- 단점
  - 스레드 간 보호 불가능
    - 스레드 중 I/O 작업 등에 의해 하나라도 블록이 걸릴 경우 전체 스레드가 블록됨.

## 커널 영역 스레드

- 커널이 스레드와 관련된 모든 작업을 관리함. 커널에 종속적.
- 멀티 스레드 프로세스 환경에서 동작한다.
- 커널이 각 스레드를 개별적으로 관리한다. 1:1 매핑
- 사용자 수준 스레드의 한계 극복.
- 장점
  - 각 커널이 스레드를 개별적으로 관리하므로 병행처리 가능.
    - 커널이 직접 제공해주기 때문에 안정성과 다양한 기능이 제공된다.
- 단점
  - 커널-유저 모드 간 전환이 빈번하게 이루어지기 때문에 오버헤드가 커진다.

## 혼합형 스레드

- 사용자 수준 스레드 + 커널 수준 스레드 => N:M 매핑
- 경량 프로세스 하나를 중간에 두어 한개 이상의 사용자 수준 스레드와 연결된다.
- 한개의 경량 프로세스는 하나의 커널 스레드와 연결된다.
- 즉, 각 작업은 경량 프로세스를 한개 이상 가지고 경량 프로세스는 대응되는 커널 스레드를 갖는다.
- 장점
  - 어떤 작업의 경량 프로세스가 입출력 완료를 기다리더라도, 프로세서는 그 작업의 다른 경량 프로세스로 이동하여 작업을 수행할 수 있다.
  - 대기가 전체 작업(프로세스)가 아닌 경량 프로세스 단위로 이루어진다.
  - 스레드 풀링 기법을 통해 일대일 스레드 매핑에서의 오버헤드를 줄여줌.

## 쓰레드 풀

- 쓰레드가 자주 생성되고 제거되는 상황에서 새로 쓰레드를 만드는 시간이 실제 쓰레드가 동작하는 시간보다 긴 경우가 존재한다. 쓰레드는 시스템의 자원이기 때문에, 시스템의 동작을 보장하는 최대한의 쓰레드 수에 대한 제한이 필요하다. 이에 대한 해결 방안으로 나온 것이 쓰레드 풀이다.
- 새로운 쓰레드가 필요하면 풀에서 가져오고, 작업이 끝나면 그 쓰레드를 제거하지 않고 다시 풀에 넣어 둔다. 이와 같이 풀을 통해 제한된 수의 쓰레드를 관리하면, 그러지 않은 경우보다 쓰레드 생성에 걸리는 시간이 줄어든다.
