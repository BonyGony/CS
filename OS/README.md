# 1. 프로세스 VS 쓰레드

## 프로세스

- 코드(프로그램)가 메모리에 적재되어 실행된 상태 or 자원을 할당받는 작업단위.
- 메모리에 올라갈 때 운영체제로부터 시스템 자원을 할당받게 된다. 프로세스마다 독립된 메모리 영역 code/data/stack/heap 영역을 할당 받는다.
  - stack -> 함수의 매개변수, 복귀 주소 지역 변수와 같은 함수 호출 정보를 가짐.
  - data -> 전역 변수들을 가짐.
  - heap -> 동적으로 할당되는 메모리.

## stack

- 함수호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다.
- 스텍 영역은 함수호출과 함께 할당되며, 호출이 완료되면 소멸된다.
- 스택 영역에 저장되는 호출 정보를 '스택 프레임'이라고 한다.
  - 스택 프레임 : 높은 주소에서 낮은 주소로 쌓이고 각 함수당 지역변수, 매개변수, 반환주소값을 가지고 있다.

|                  프로그램                  | VS  |                  프로세스                  |
| :----------------------------------------: | :-: | :----------------------------------------: |
| 코드와 같은 정적 데이터를 가진 정적인 객체 |     | 현재 관리하는 자원 정보를 가진 동적인 객체 |

### 프로세스 제어 블록(Process Control Block, PCB)

- 프로세스의 상태정보를 저장하고 있는 구조체이다.
- 프로세스 생성시 만들어지며 주기억장치에 유지된다.
- 프로세스 상태관리와 문맥교환을 위해 필요하다.

  - 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다. 프로세스는 CPU를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU를 반환해야 한다. 이때, 작업의 진행 상황을 모두 PCB에 저장하게 된다. 그리고 다시 CPU를 할당받게 되면 PCB에 저장되어있던 내용을 불러와 이전에 종료되었던 시점부터 다시 작업을 수행한다.

    | PCB                    | 설명                          |
    | :--------------------- | :---------------------------- |
    | PID                    | 프로세스의 고유 번호          |
    | Process state          | 준비,대기,실행 등의 상태      |
    | Priority               | 스케줄링 및 프로세스 우선순위 |
    | 포인터                 | 다음 실행될 프로세스의 포인터 |
    | Register information   | 레지스터 관련 정보            |
    | Memory information     | 할당된 자원 정보              |
    | Accounting information | CPU 사용시간, 실제 사용시간   |
    | I/O information        | 입출력 상태 정보              |

---

## 쓰레드

- 프로세스 내에 실행되는 실행 흐름의 단위
- 프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지는 같은 프로세스 내 다른 쓰레드와 공유한다.

### 쓰레드마다 스택을 독립적으로 할당하는 이유

- 스택은 함수호출 정보를 저장하기 위해 사용되는 메모리 공간이다.
- 스택 메모리 공간이 독립적이라는 것은 독립적인 함수호출이 가능하다는 것이고, 이는 독립적인 실행 흐름이 추가된다는 것이다.

---

# 2. 멀티 프로세스와 멀티 쓰레드

- 멀티 프로세스

  - 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 1개의 작업을 처리하도록 하는 것.
  - 장점
    - 각 프로세스는 서로 영향이 없어 하나에 문제가 발생하더라도 나머지는 정상 작동한다.
  - 단점
    - 많은 메모리 공간과 CPU시간을 차지한다.
    - 각각의 고유한 메모리 공간을 가지므로 자원 공유시 오버헤드가 크다.
    - 문맥교환에 비용이 많이 든다.

- 멀티 쓰레드
  - 하나의 프로세스를 여러 스레드로 병렬처리 하는 것.
  - 장점
    - 모든 스레드가 서로 자원과 메모리를 공유하므로 적은 메모리 공간과 문맥교환이 빠르다.
  - 단점
    - 교착상태가 발생할 수 있다. 여러 쓰레드가 하나의 자원에 동시에 접근.
    - 서로 영향을 미치므로 하나에 이상이 생기면 전체 쓰레드에 영향을 미친다.

---

# 3. 사용자 수준 쓰레드, 커널 수준 쓰레드, 혼합 쓰레드

- 메모리 영역은 사용자에 의해 할당되는 '유저 영역', 운영체제라는 소프트웨어를 실행시키기 위한 '커널 영역'으로 나뉜다.
- 사용자레벨 쓰레드와 커널레벨 쓰레드는 생성 주체가 누구인지에 따라 구분된다.

## 사용자 수준 쓰레드

- 쓰레드와 관련된 모든 행위를 사용자 영역에서 한다.
- 쓰레드 라이브러리를 이용하여 작동하는 형태.
- 단일 프로세서에서 작동한다. N:1 매핑
- 커널이 쓰레드의 존재를 알지 못 한다.
- 장점
  - 이식성이 높다.
    - 운영체제에서 스레드를 지원할 필요가 없다.
    - 커널 모드/유저 모드 간 전환이 일어나지 않기에 오버헤드가 적다.
- 단점
  - 스레드 간 보호 불가능
    - 스레드 중 I/O 작업 등에 의해 하나라도 블록이 걸릴 경우 전체 스레드가 블록됨.

## 커널 영역 스레드

- 커널이 스레드와 관련된 모든 작업을 관리함. 커널에 종속적.
- 멀티 스레드 프로세스 환경에서 동작한다.
- 커널이 각 스레드를 개별적으로 관리한다. 1:1 매핑
- 사용자 수준 스레드의 한계 극복.
- 장점
  - 각 커널이 스레드를 개별적으로 관리하므로 병행처리 가능.
    - 커널이 직접 제공해주기 때문에 안정성과 다양한 기능이 제공된다.
- 단점
  - 커널-유저 모드 간 전환이 빈번하게 이루어지기 때문에 오버헤드가 커진다.

## 혼합형 스레드

- 사용자 수준 스레드 + 커널 수준 스레드 => N:M 매핑
- 경량 프로세스 하나를 중간에 두어 한개 이상의 사용자 수준 스레드와 연결된다.
- 한개의 경량 프로세스는 하나의 커널 스레드와 연결된다.
- 즉, 각 작업은 경량 프로세스를 한개 이상 가지고 경량 프로세스는 대응되는 커널 스레드를 갖는다.
- 장점
  - 어떤 작업의 경량 프로세스가 입출력 완료를 기다리더라도, 프로세서는 그 작업의 다른 경량 프로세스로 이동하여 작업을 수행할 수 있다.
  - 대기가 전체 작업(프로세스)가 아닌 경량 프로세스 단위로 이루어진다.
  - 스레드 풀링 기법을 통해 일대일 스레드 매핑에서의 오버헤드를 줄여줌.

## 쓰레드 풀

- 쓰레드가 자주 생성되고 제거되는 상황에서 새로 쓰레드를 만드는 시간이 실제 쓰레드가 동작하는 시간보다 긴 경우가 존재한다. 쓰레드는 시스템의 자원이기 때문에, 시스템의 동작을 보장하는 최대한의 쓰레드 수에 대한 제한이 필요하다. 이에 대한 해결 방안으로 나온 것이 쓰레드 풀이다.
- 새로운 쓰레드가 필요하면 풀에서 가져오고, 작업이 끝나면 그 쓰레드를 제거하지 않고 다시 풀에 넣어 둔다. 이와 같이 풀을 통해 제한된 수의 쓰레드를 관리하면, 그러지 않은 경우보다 쓰레드 생성에 걸리는 시간이 줄어든다.

# 4. 교착상태(DeadLock)와 기아상태

- 교착상태와 기아상태의 차이점

  - 교착상태
    - 자원을 자유롭게 할당한 결과(자원 부족)
  - 기아상태
    - 기다리는 결과를 예방하기 위해, 자원할당할 때 발생하는 결과

- 교착상태

  - 둘 이상의 프로세스가 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상태.
  - 교착 상태는 하나 이상의 작업에 영향을 주기 때문에 무한 대기나 기아 상태보다 더 심각한 문제를 일으킨다.

- 기아상태
  - 프로세스의 우선순위가 낮아서 원하는 자원을 경코 할당받지 못하여 영원히 기다리는 상태.

## 교착 상태의 4가지 조건

- 4가지 조건이 모두 만족할 경우 교착상태가 발생한다.
  - 상호 배제
    - 한 리소스는 한 번에 한 프로세스만 사용할 수 있다.
  - 점유와 대기
    - 어떤 프로세스가 하나 이상의 리소스를 점유하면서 다른 프로세스사 가지고 있는 리소스를 기다리고 있다.
  - 비선점
    - 프로세스가 태스트를 마친 후 리소스를 자발적으로 반환할때까지 기다린다.(강제로 뺏지 않는다.)
  - 환형 대기
    - 점유와 대기 관계의 프로세스들이 서로 기다린다.

## 교착 상태의 해결법

- 운영체제가 교착상태를 해결하지 못할 경우, 시스템 운영자나 사용자가 작업을 교체하거나 종료하는 외부 간섭으로 해결한다.
  - 방지
    - 할당 구조 측면에서, 교착상태가 발생할 수 있는 요구조건을 만족시키지 않게 한다.
    - 그러나 4가지 중 1가지 조건을 깨는 것은 쉽지 않다.
      - 상호 배제를 깨면 여러 프로세스가 자원을 공유하게 되면서 문제발생.
      - 점유와 대기를 깨면 자원이 오랫동안 할당되고 사용되지 않으면서 낭비될 수 있다.
      - 비선점을 깨면 공유 자원에 대한 상호 배제가 의미가 없어진다.
      - 환형대기가 그나마 부정 가능함. 선형대기로 만들어 공유 자원 사이에 순서를 정해줌.
    - 시스템 처리량이나 자원 사용의 효율성을 떨어뜨림.
  - 회피
    - 교착상태가 발생할 가능성이 있는 자원 할당을 하지 않고 안전한 상태에서만 자원 요청을 허용함.
    - 아래와 같은 가정필요.
      - 프로세스 수 고정.
      - 자원의 종류와 수 고정.
      - 프로세스가 요구하는 최대 자원의 수를 알아야 함.
      - 프로세스는 자원 사용 후 반드시 반납.
    - 문제 발생에 대한 일관성과 가정이 완벽할 것이라는 것을 보장하기가 현실적으로 어렵다.
    - 교착상태를 발생시킬 수 있다고 판단한 경우 자원할당 거부(대표 알고리즘 : 은행원 알고리즘, 자원 할당 그래프)
      - 은행원 알고리즘
        - 최소한 하나의 프로세스에게 할당해줄 만큼의 자원은 CPU가 보유하고 있어야 한다.
        - 미리 자원의 최대 요구량을 알아야 하고, 할당할 자원의 수가 일정해야 하는 단점.
      - 자원 할당 그래프 알고리즘
        - 자원 할당 그래프에 예약 간선을 추가하여 예약 간선으로 설정한 자원에 대해서만 자원 할당을 요구할 수 있고, 사이클이 형성되지 않을 때만 자원을 할당받는 방법.
        - 사이클 발생 시, 교착상태일 가능성이 있음.
  - 탐지
    - 시스템에 데드락이 발생했는지 확인하고 회복 기법 알고리즘에 활용.
    - 그러나 지속적으로 확인해야 하므로 오버헤드가 발생.
  - 회복
    - 교착상태가 발생할 수 있도록 두고, 교착상태가 발생 할 경우 찾아내어 고친다.
    - 사용자가 직접 처리
      - 교착 상태에 걸려있는 프로세스 중 하나를 사용자가 강제로 종료시킴.
    - 시스템에 의한 처리
      - 프로세스 중지
        - 교착상태가 해결될때까지 1개의 프로세스씩 종료
          - 탐지를 N번 해야 하므로 오버헤드가 크다.
        - 교착상태에 속한 모든 프로세스 중지.
          - 비용이 크다.
      - 자원 선점
        - 교착상태에 빠진 프로세스들의 자원을 빼앗아 다른 프로세스에게 할당한다.
        - 아래 세가지 사항을 해결해야 한다.
          - 선점 프로세스 선택
            - 우선 순위 설계
          - 복귀
            - 자원을 잃은 프로세스를 안전상태로 복구
          - 기아
            - 비용에 근거한 선점은 계속 동일한 프로세스가 선택되어 재발할 수 있다.
            - 매번 결과가 다르도록 선점 횟수 등을 포함해야 한다.

# 5. Context Switching

- 멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선순위의 프로세스가 실행되어야 할 때
- 기존의 프로세스의 상태 또는 레지스터 값을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업.
- context switching을 하는 동안은 cpu는 아무런 일을 하지 못한다. 따라서 잦아지면 오버헤드 발생.

## Context란?

- CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들이다.
- context는 프로세스의 PCB에 저장된다.

## 인터럽트

- cpu가 프로그램을 실행하고 있을 때 실행중인 프로그램 밖에서 예외 상황이 발생하여 처리가 필요한 경우, cpu에게 상황을 처리할 수 있도록 하는 것을 말한다.
  - I/O request : 입출력 요청
  - time slice expired : cpu 사용시간이 만료
  - fork a child : 자식 프로세스를 만들 때
  - wait for an interrupt : 인터럽트 처리 기다릴 때
  - 등등

# 6.프로세서(CPU) 스케줄링

- 프로세스가 생성되어 실행될 때 필요한 시스템의 여러자원을 해당 프로세스에게 할당하는 작업을 의미함.
- 장기 스케줄링
  - 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가을 결정하여 준비상태큐로 보내는 작업.
- 중기 스케줄링
  - 어떤 프로세스들이 CPU를 할당 받을 것인지 결정하는 작업을 의미.
- 단기 스케줄링
  - 프로세스가 실행되기 위해 cpu를 할당받는 시기와 특정 프로세스를 지정하는 작업을 의미.

## 선점 스케줄링

- 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때, 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법.

  - 주로 빠른 응답시간을 요구하는 대화식 시분할 시스템에 사용됨.
  - 장점
    - 우선순위가 높은 프로세스를 빠르게 처리할 수 있다.
  - 단점
    - 우선순위가 높은 프로세스가 생길 때마다 계속 문맥교환이 일어나므로 오버헤드가 크다.

- RR(라운드로빈)
  - 프로세스 사이에 우선순위를 두지 않고, 순서대로 시간단위로 CPU할당.
  - 문맥 전환의 오버헤드가 크지만 응답시간이 짧아짐.
- SRT
  - SJF를 선점 형태로 변경한 기법.
  - 가장 점유 시간이 짧은 프로세스에 먼저 할당하지만, 중요한 프로세스가 있으면 먼저 실행 시킬 수 잇음.
- MLQ(다단계 큐)
  - 프로세스를 특정 그룹으로 분류할 수 있을 경우, 그룹에 따라 각기 다른 분비 상태 큐를 사용하는 기법.
  - 하위 준비 상태 큐에 있는 프로세스를 실행하는 도중이라도 상위 준비 상태 큐에 프로세스가 들어오면 상위 프로세스에게 할당해야함.
  - 각 큐는 독자적 스키줄링 기법 사용 가능.
  - 우선순위가 낮은 프로세스는 기아 현상이 발생할 수 있음.
  - 프로세스는 배정된 큐에서 다른 큐로 움직일 수 없음.
- MFQ(다단계 피드백 큐)
  - 다단계 큐에 동적인 우선 순위 변화 적용
  - 프로세스 생성 시 가장 높은 우선 순위 준비 큐에 등록되며 FCFS 순서로 CPU 할당
  - CPU 시간 할당량이 끝나면 한 단계 아래 준비 큐에 들어감
  - 단계가 내려갈수록 시간 할당량이 증가한다.
  - 맨 아래 큐에서 너무 오래 대기하면 다시 상위 큐로 이동
    - 에이징 기법을 통한 기아상태 예방
  - 프로세스는 배정된 큐에서 다른 큐로 움직일 수 있음.

## 비선점 스케줄링

- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄 기법. 프로세스가 CPU를 할당받을 경우 해당 프로세스가 완료될 때까지 인터럽트 없이 CPU를 사용한다.

  - 일괄처리 방식에 적합하다.
  - 장점
    - 프로세스 응답 시간을 예측하기 쉽다.
  - 단점
    - 중요한 작업이 중요하지 않은 작업을 기다리는 경우가 발생할 수 있다.

- FIFO, FCFS
  - 선입선출 방식. 먼저 들어오면 먼저 나감
  - 중요한 작업이라도 먼저 들어온 작업이 끝날때 까지 실행 안된다는 단점.
- SJF
  - cpu 점유 시간이 가장 짧은 프로세스에 먼저 할당.
  - 실행 시간이 긴 프로세스는 순위가 밀려 기아 상태에 빠질 수 있음.
- HRN(Highest Response-ratio Next)

  - 실행시간이 긴 프로세스에 불리한 SJF를 보완하기 위한 기법
  - 대기 시간과 서비스 시간을 이용하는 방식
  - 우선순위 : (대기시간+서비스시간)/서비스시간
  - 우선순위 높은 것부터 실행
  - 프로세스가 자원을 기다리는 시간에 비례하여 우선순위를 부여함으로 무한 연기 문제 방지
    - 에이징 기법

- 요즘 사용하는 스케줄링 기법
- sync async
- blocking nonblocking

# 6. Blocking VS Non-Blocking, Synchronous VS Asynchronous

- Blocking VS Non-Blocking

  - 보통 I/O 작업에서 사용되는 개념으로, 호출한 함수가 일을 할 수 있냐 없냐로 나움.
  - Blocking
    - 호출된 함수가 제어권을 가지고 있어 호출한 함수는 대기상태.
  - Non-Blocking
    - 호출된 함수가 결과에 관계없이 제어권을 바로 돌려준다. 호출한 함수는 일을 할 수 있다.

- Synchronous VS Asynchronous

  - 보통 어플리케이션에서 사용되는 개념, 작업이 순차적으로 처리되나 아니냐를 구분.
  - Synchronous
    - 작업1의 작업 응답과 동시에 작업2의 작업 요청이 들어와 순차적으로 실행할 수 있도록 함.
    - 계속해서 작업들의 요청을 신경써야 한다.
  - Asynchronous
    - 응답에 신경쓰지 않고 내버려 둔다. 동시 다발적으로 실행 가능.

- 선생과 학생들을 예시로 든다.

- 동기 & 블록킹

  - 학생이 자습을 순서대로 끝마칠때까지 무한정 대기.
  - 자습이 다 끝나면 퇴근.

- 동기 & 논블록킹

  - 학생이 자습을 순서대로 끝마칠때까지 딴짓함.
  - 자습이 다 끝나면 퇴근.

- 비동기 & 논블록킹

  - 선생은 아무신경 안 쓰고 출근과 동시에 퇴근한다.

- 비동기 & 블록킹
  - 예시가 없음
  - 직관적인 코드의 흐름을 유지하면서 작업을 병렬적으로 처리하기 위해 Linux/UnixS OS의 I/O 다중화 모델 등에서 사용된다.
  - 동기 & 블록킹 I/O의 경우 직관적이나, 여러 개의 I/O를 동시에 처리할 수 없다.
  - 논블록킹 I/O는 프로세스들의 작업을 컨트롤하는 것이 까다롭다.
  - 그렇다고 동기 & 블록킹 I/O와 멀티 프로세싱이나 쓰레딩을 결합해서 쓰자니 자원 문제도 있고 프로세스/쓰레드 간 통신이나 동기화가 빡셈

# 7. 프로세스 동기화

- Race Condition(경쟁 상태)
  - 여러 프로세스들이 동시에 데이터에 접근하는 상황에서, 어떤 순서로 데이터에 접근하느냐에 따라 결과 값이 달라질 수 있는 상황을 말한다.
  - 공유 데이터의 동시 접근(Concurrent access)은 데이터의 불일치 문제를 발생시킬 수 있다. 따라서, Race condition을 막고 일관성을 유지하기 위해서는 협력 프로세스 간의 실행 순서를 정해주는 메커니즘인 동기화(Synchronization)가 필요하다.
  - 대표적으로 세가지 경우에서 경쟁 상태가 발생 가능.
    - 커널 모드로 수행 중 인터럽트가 발생하는 경우
      - 커널 모드의 수행이 끝나기 전에는 인터럽트를 받지 않도록 하는 방법이 있음
    - 프로세스가 시스템 콜을 호출해서 커널 모드로 수행 중인데 Context switch가 발생하는 경우
      - 두 프로세스의 주소 공간에서는 데이터를 공유하지 않지만, 시스템 콜을 수행하는 동안에는 둘 다 커널 주소 공간의 데이터를 접근한다. 따라서 커널 주소 공간에서 작업을 수행하는 도중에 CPU를 빼앗으면 race condition이 발생한다.
      - 커널 모드를 수행 중일 땐 CPU가 preempt 되지 않도록 하고, 커널 모드에서 유저 모드로 돌아갈 때 preempt 되도록 함으로써 해결할 수 있다.
    - 멀티 프로세서에서 공유 메모리 내의 커널 데이터에 접근하는 경우
      - 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대해서만 lock/unlock을 하는 방식으로 해결할 수 있다.
- Critical Section(임계 구역)
  - 코드 상에서 Race condition이 발생할 수 있는 특정 부분
    - Mutual Exclusion(상호 배제)
      - 이미 한 프로세스가 Critical Section에서 작업 중이면 다른 모든 프로세스는 Critical Section에 진입하면 안 된다.
    - Progress(진행)
      - Critical Section에서 작업 중인 프로세스가 없다면, Critical Section에 진입하고자 하는 프로세스가 존재하는 경우 진입할 수 있어야 한다.
    - Bounded Waiting(한정 대기)
      - 프로세스가 Critical Section에 들어가기 위해 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 Critical Section에 들어가는 횟수에 한계가 있어야 한다. 쉽게 말해, Critical Section에 진입하려는 프로세스가 무한정 기다려서는 안 된다.

## Synchronization Algorithms

- Synchronization Variable
  - 현재 Critical Section에 들어갈 프로세스가 어떤 프로세스인지를 한 변수로 나타내어 일치하는 프로세스만 진입하도록 하는 단순한 방식이다.
  - Mutual Exclusion은 만족하지만 Progress는 만족하지 못한다.
- Synchronization Variable
  - 특정 프로세스가 Critical Section에 진입할 준비가 되었다는 것을 나타내는 변수를 두어, 다른 프로세스가 Critical Section에 진입하려고 한다면 현재 프로세스는 기다리는 방법이다.
  - Mutual Exclusion은 만족하지만 Progress는 만족하지 못한다.
- Peterson's Algorithms
  - Peterson's Algorithm은 이전의 알고리즘 1과 2를 합쳐놓은 개념이다. turn 변수와 flag 변수를 동시에 사용한다.
  - Mutual Exclusion, Progress, Bounded waiting 모두 만족한다.
  - Critical Section 진입을 기다리면서 계속 CPU와 메모리를 사용하는 Busy Waiting의 문제점
